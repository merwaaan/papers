\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{float}
\usepackage{nonfloat}
\usepackage{tikz}

% FAMFAMFAM.com colors
\definecolor{mpink}{RGB}{255,11,91}
\definecolor{mblue}{RGB}{11,206,255}
\definecolor{mgreen}{RGB}{123,255,45}

\setlength{\textwidth}{39pc}
\setlength{\textheight}{50pc}
\setlength{\parindent}{1em}
\setlength{\parskip}{0pt plus 1pt}
\setlength{\oddsidemargin}{0pc}
\setlength{\marginparwidth}{0pc}
\setlength{\topmargin}{1pc}
\setlength{\headsep}{20pt}
\setlength{\columnsep}{2pc}

\title{Recherche décentralisée de connexité pour réseaux de capteurs mobiles}
\author{Merwan Achibet}
\date{}

\begin{document}

\maketitle

\begin{multicols}{2}

\section*{Introduction}

On traite le problème suivant : un groupe de $n$ capteurs mobiles est
réparti aléatoirement dans un espace aérien. On part de l'hypothèse
qu'un capteur connaît uniquement le nombre total de capteurs du
système et qu'il est assez sophistiqué pour pouvoir déterminer
précisément sa position absolue. Les capteurs sont dotés de matériel
de communication sans fil et peuvent s'envoyer des messages à
condition que la distance les séparant soit inférieure à leur rayon
d'émission $R_c$.

Le réseau constitué par cet essaim d'appareils volants forme un graphe
dynamique dont les n\oe uds sont les capteurs. Deux n\oe uds sont
reliés par un arc si les capteurs qui leur sont associés sont en
mesure de communiquer, c'est à dire s'ils sont assez proches. La
figure \ref{communication} décrit un exemple de scénario impliquant
trois capteurs.

\begin{figure}[H]

  \centering

  \input{communication.tikz}

  \caption{Les capteurs rose et bleu peuvent communiquer et sont
    connectés tandis que le capteur vert est isolé.}
  \label{communication}

\end{figure}

On considère un capteur comme un agent autonome capable de se mouvoir
dans l'espace. Afin de ne pas se préoccuper de considérations
géométriques superflues, il est supposé qu'un capteur conserve
toujours la même altitude et donc on limite son déplacement à deux
dimensions. La contrainte principale de cet exercice est que l'on
refuse toute forme de contrôle global sur l'essaim de capteurs. Toutes
les actions entreprises par un appareil seront uniquement dû à ses
décisions propres et dépendront de la vue réduite du système dont il
dispose.

La possibilité pour un capteur de communiquer avec ses semblables est
au centre de nos préoccupations car on considère qu'un capteur isolé
est inutile puiqu'incapable de partager des données. Dans le contexte
de l'étude décentralisée d'un graphe dynamique, deux questions se
posent :

\begin{enumerate}
\item{Comment déterminer si le réseau de capteurs est connexe ?}
\item{Comment déplacer les capteurs de façon à ce qu'il le devienne ?}
\end{enumerate}

Pour répondre à la première question, on se concentre sur les
communications de capteur à capteur en proposant une méthode pour
laquelle chaque agent diffuse sa vision de la connexité du réseau,
étiquettée en fonction de la date de l'information. Un mécanisme de
filtrage autorégulant sera mis en place pour répandre les informations
critiques telles que l'ajout d'un nouveau n\oe ud à une composante
connexe.

La réponse à la seconde question s'attache à l'aspect mobile d'un
capteur. On propose une méthode de guidage décentralisé se basant sur
l'imitation de plusieurs lois physiques de la nature afin de former un
maillage à la fois connexe, équilibré et étalé dans
l'espace. Finalement, on envisage une extension de ce système pour
permettre aux capteurs d'éviter naturellement les obstacles.

\section{Déterminer si le réseau est connexe}

Dans cette section, on se place du point de vue d'un capteur $c$ et
l'on considère que le réseau est connexe lorsque $c$ le pense connexe.

Les capteurs étant mobiles, le réseau de communication qu'ils forment
est hautement dynamique et des événements impromptus, comme le
déplacement d'un capteur ou une panne, peuvent à tout moment faire
varier la connexité du graphe résultant. Comme énoncé précédemment,
$c$ a connaissance du nombre de capteurs $n$ du système. Déterminer la
connexité du réseau revient donc à un problème de comptage
décentralisé, o\`u $\tilde{n}$ est le nombre de capteurs que $c$ sait
connectés à sa propre composante connexe, et le graphe est connexe si
$\tilde{n} = n$.

L'idée que l'on présente ici repose sur un partage permanent, entre
voisins, de la vision du réseau que chaque capteur entretient. Si l'on
pouvait traduire en langue humaine un message de $c$ à $c'$, on
entendrait :

\begin{quote}
  \textit{Je suis $c$ et je sais que $x$ à été vu dans le réseau il y
    a 14 secondes. Par contre, je n'ai pas eu de nouvelles de mon
    voisin $y$ depuis un certain temps, je doute qu'il soit toujours
    présent dans le réseau.}
\end{quote}

Dans notre méthode, un capteur transmet régulièrement à ses voisins
son avis sur la présence ou non d'un n\oe ud dans leur composante
connexe. Afin de permettre de gérer des informations contradictoires,
une date est associée à chaque information de n\oe ud. L'objectif
envisagé est de concevoir un système dans lequel les données sont
diffusées par transmission entre voisins, fusion des informations de
présence et filtrage des informations contradictoires.

On suppose que les capteurs disposent d'une MEMOIRE SYNCHRO

\subsection*{Liste de voisins directs}

La première liste, $N$, représente le voisinage de $c$ et contient
uniquement les identifiants des n\oe uds en liaison directe avec ce
dernier.

Un n\oe ud est ajouté à $N$ si $c$ en reçoit un message et qu'il
n'était pas déja présent dans la liste. Un n\oe ud est retiré de $N$
si $c$ n'en a pas reçu de message depuis un certain temps, c'est le
mécanisme de surveillance.

On choisit ici de rendre les capteurs proactifs : leurs messages sont
envoyés volontairement à intervalle régulier afin d'informer leurs
voisins de leur présence. Ainsi, on considère qu'un capteur a
potentiellement disparu d'un voisinage s'il n'envoie plus de message.

\subsection*{Liste de n\oe uds connectés}

La seconde liste entretenue par un capteur est $C$. Elle représente sa
vision de la connexité du réseau, soit concrètement, tous les n\oe uds
qui, de son point de vue, y sont connectés directement (par la liaison
sans-fil) ou indirectement (par l'intermédiaire d'autres capteurs). On
peut donc en déduire que tous les n\oe uds de $N$ apparaissent dans
$C$.

Cependant, et contrairement à $N$, $C$ ne contient pas que des
identifiants. Ses entrées sont de la forme $(x,t)$ avec $x$
l'identifiant du n\oe ud dont l'on veut exprimer la présence sur la
composante connexe et $t$ le dernier temps auquel $x$ a été détecté.

Par exemple, si un capteur a dans sa liste $C$ l'entrée $(y,52)$,
cela signifie qu'il sait que le capteur $y$ fait partie de la même
composante connexe que lui car il a été détecté au temps 52. Il est
important de noter que le n\oe ud $y$ peut potentiellement se trouver
à l'autre bout du réseau et que l'identité du capteur responsable de
sa détection ne nous est d'aucune utilité.

\subsection*{Liste de doutes}

La troisième et dernière liste, $D$, contient une liste de capteurs
dont $c$ n'est plus certain de la connexité. Ses entrées prennent la
forme de paires $(x,t)$ o\`u $x$ est le n\oe ud sur lequel le doute se
pose et $t$ la date à laquelle l'absence de $x$ a été dernièrement
remarquée.

On ajoute une entrée $(z,t)$ à $D$ lorsque $z$ est présent dans la
liste $N$ des voisins mais que, par surveillance, on se rend compte au
temps $t$ qu'il n'a pas communiqué depuis un certain temps. \`A
l'inverse, cette même paire migre de la liste de doutes vers la liste
de connexité si une nouvelle communication est plus tard détectée (le
$t$ est alors mis à jour pour réfléter ce changement).

Il est évident qu'un n\oe ud ne peut être présent à la fois dans $C$
et $D$. Ce constat nous permet de borner l'espace mémoire nécessaire à
$2n$ informations : $n$ informations dans la liste de voisins si le
graphe est complet, $n$ informations au maximum réparties entre la
liste de connexité et la liste de doutes.

\subsection*{Balisage, fusion et filtrage}

Pour l'instant les seuls événements ayant amené à modifier les listes
du capteur $c$ étaient liés à son voisinage direct (un message d'un
nouveau voisin est reçu ou un ancien voisin disparaît). Le balisage
est l'action, pour un capteur, de régulièrement partager sa liste de
connexité et sa liste de doutes avec ses voisins. Le balisage ne
modifie pas l'état interne du n\oe ud l'éxécutant mais celui des
voisins le captant; qui fusionnent les listes reçues avec les leurs en
suivant quelques règles simples.

En l'absence de conflit, les informations du message de l'émetteur
sont intégrées à la mémoire interne du récepteur. Par exemple, si $c$
envoie sa liste $C = \{\dots,(d,27),\dots\}$ à $c'$ et que ce
capteur n'a pas d'entrée relative au n\oe ud $d$ dans ses listes alors
on lui ajoute. $c'$ aura donc comme nouvelle liste $C' =
\{\dots,(d,27)\}$.

En cas de conflit par contre, on se base toujours sur la date liée à
l'information pour déterminer quel capteur a raison et choisir ou non
d'intégrer l'information provenant de l'émetteur. Par exemple, $c$
envoie sa liste $C = \{\dots,(f,12),\dots\}$ à $c'$ ayant comme liste
$D' = \{\dots,(f,16),\dots\}$. Cela signifie que $c$ pense que le
capteur $f$ est présent sur le réseau depuis au moins le temps 12
tandis que $c'$ pense qu'il a quitté le réseau depuis le temps 16. En
conséquence, on ignore l'avis de $c$ car on préfère faire confiance
aux données les plus récentes.

Autre situation envisageable : $c$ envoie $C = \{\dots,(g,35),\dots\}$
à $c'$ ayant $C' = \{\dots,(g,22),\dots\}$. Ici, les deux capteurs
partagent le même avis sur la présence de $g$ dans le réseau mais on
modifie tout de même $C' = \{\dots,(g,35),\dots\}$ afin que la date de
la dernière détection puisse se propager dans le système.

Ces quelques exemples illustrent l'idée de cette méthode de comptage
décentralisée basée sur le fait que seuls les voisins directs peuvent
affirmer avec certitude la présence ou non d'un capteur dans le réseau
tout en diffusant cette information, en l'étiquettant temporellement,
de façon à ???.Un exemple graphique est visible sur la figure
\ref{connexite}.

DEFAUTS/AVANTAGES

\section{Rendre le réseau connexe}

La résolution de ce problème passe par la satisfaction de deux besoins
\textit{a priori} antagonistes. D'une part, il est naturellement
nécessaire de réunir les capteurs dans un espace réduit, de façon à ce
qu'ils puissent communiquer et échanger des données en
continu. D'autre part, et dans l'interêt de leurs utilisateurs, ils
doivent s'étaler dans l'espace afin d'effectuer des mesures sur la
plus grande superficie possible. Nous sommes donc dans une situation
de compromis, dans laquelle une contrainte technique (la portée de
communication) force à agglomérer les capteurs en une même zone,
tandis que leur but premier est de relever des données en masse et
donc, rationnellement, de s'éloigner les uns des autres pour couvrir
le plus de terrain possible. La seule issue favorable à ce problème
est donc d'aboutir à une situation d'équilibre satisfaisant ces deux
contraintes diamétralement opposées.

Le cadre de cet exercice s'accorde parfaitement avec la problèmatique
de la prise de décision dans un réseau décentralisé puisque chaque
capteur peut être assimilé à un agent autonome, capable d'agir sur la
configuration de son environnement en se déplaçant dans l'espace. Quel
que soit l'état d'un capteur, la vision du système dont il dispose est
locale et doit servir seule à déterminer quelles actions il
entreprend. L'objectif est donc ici de proposer une méthode de guidage
que chaque capteur peut adopter et qui, par émergence d'une dynamique
globale, résoudra notre problème en répartissant les capteurs dans
l'espace de façon satisfaisante.

Les boïds de Craig Reynolds \cite{Reynolds1987} sont reconnus pour
simuler un comportement de groupe a priori complexe et synchronisé à
partir d'un jeu de règles simples. On s'en inspire, ainsi que d'un
modèle de mouvement particulaire \cite{Cheng2011497} se basant sur la
répulsion entre molécules de gaz, pour concevoir les trois règles qui
gouverneront notre système. Chacune de ces lois, que l'on présente
séparément par la suite, va engendrer une influence sur le déplacement
de nos capteurs; influence dont la composition sera détaillée en
dernière partie.

\subsection*{Attraction}

\`A la lecture de l'énoncé de ce problème, la nécessité de rapprocher
les capteurs les uns des autres, afin qu'un réseau de communication
ininterrompu se forme, vient naturellement à l'esprit. En effet, la
condition \textit{sine qua non} au bon fonctionnement du réseau est la
communication. Un capteur isolé est inutile puisque son
information n'est pas partagée.

Par sa loi de la gravitation universelle, Isaac Newton décrit la force
qui attire toute paire de corps comme étant proportionnelle à leur
masse respective et à la distance les séparant \cite{newton}. Nous
nous permettons de simplifier quelque peu son équation et d'en retirer
l'aspect massique pour obtenir une règle qui a tout couple de corps
associe une attraction proportionnelle à leur distance. S'ils
obéissaient à cette loi, nos capteurs auraient naturellement tendance
à se grouper, et donc à se mettre à portée de communication.

\`A l'échelle de notre système, le cadre est différent de celui de la
loi de Newtion, et cette influence n'est pas universelle. Nous ne
pouvons malheureusement pas réécrire les règles de ce monde et
inventer une attirance magique entre toute paire de capteurs. On peut
néanmoins la simuler. Si deux capteurs sont à portée et peuvent
échanger leur positions respectives alors la détermination de la
distance les séparant est aisée. \`A partir de là, on peut imiter un
phénomène d'attration.

Concrètement, on associe à tout capteur $c$ un rayon d'attraction
$R_a$ (voir figure \ref{attraction}). Si un capteur voisin se trouve à
la fois dans le rayon de communication $R_c$ de $c$ et à l'extérieur
de $R_a$, la force d'attraction que ce capteur devra subir est fournie
par la formule suivante :

$$
\vec{a} = \frac{\vec{p}_c - \vec{p}_v}{|\vec{p}_c - \vec{p}_v|^2}
$$

\begin{figure}[H]

  \centering

  \input{attraction.tikz}

  \caption{En vert, le rayon d'attraction, dont l'intensité est
    décroissante de l'extérieur vers l'intérieur.}
  \label{attraction}

\end{figure}

Dans le phénomène d'attraction réel, l'action est réciproque mais dans
notre cas elle est unidirectionnelle. Un capteur est attiré par tous
ses voisins mais le processus décrit ne modifie pas directement la
position du voisin en question et il n'en subit aucune influence. Il
est néanmoins à prévoir que lorsque ce voisin calculera les influences
qui s'appliquent à lui, il en subira la réciproque.

On note que l'attraction n'a pas pour but d'approcher des capteurs
trop éloignés pour communiquer puisque l'existence d'une connexion
entre deux capteurs est un prérequis à l'application de la force
d'attraction. Son interêt majeur se révélera en conjonction avec la
seconde force présentée.

\subsection*{Répulsion}

L'attraction a pour effet d'agglomérer en groupes serrés tous les
capteurs démarrant la simulation dans une même zone. Mais même si de
cette façon la communication est assurée, les capteurs finissent par
tous être superposés sur la même position au bout d'un certain nombre
d'itérations et la contrainte de couverture n'est absolument pas
satisfaite.

Pour pallier cette déconvenue, on introduit une nouvelle force opposée
à l'attraction, la répulsion. Le rayon $R_r$ définit une nouvelle zone
radiale qui, contrairement à la loi précédente, expulsera les capteurs
envahissants vers l'extérieur. Il est bien sûr nécessaire que $R_r <
R_c$. L'influence qui en découle est dirigée vers l'extérieur du
capteur envahi et est inversement proportionnelle à la distance les
séparant, de façon à engendrer une répulsion plus forte vers le centre
\cite{Cheng2011497} :

$$
\vec{r} = \frac{\vec{p} - \vec{p_v}}{|\vec{p} - \vec{p_v}|^2}(R_r - |\vec{p} - \vec{p_v}|)
$$

\begin{figure}[H]

  \centering

  \input{repulsion.tikz}

  \caption{En rouge, le rayon de répulsion, dont l'intensité est
    décroissance du centre vers les bords.}
  \label{repulsion}

\end{figure}

On prend $R_r = R_a - \varepsilon$, o\`u $\varepsilon$ correspond à la
largeur d'une bande neutre entourant chaque capteur (voir figure
\ref{repulsion}). Les capteurs auront naturellement tendance à
s'installer dans ces zones libre de toute influence. Nous verrons dans
les démonstrations que la conséquence principale de ce positionnement
fortement dirigé est un maillage régulier et géométrique. La
régularité qu'adopte la structure de notre réseau est un plus à ne pas
négliger puisqu'il permet des mesures homogènes par les capteurs.

\subsection*{Gravité}

Les deux règles présentées permettent aux capteurs de s'agglomérer en
composantes connexes équilibrées mais ces composantes prennent la
forme d'îlots et la connexité totale du réseau n'est toujours pas
garantie. Dans cette optique, on introduit une dernière influence
inspirée du physique, la gravité.

Comme spécifié en introduction, on part de l'hypothèse que les
capteurs sont munis de moyens de localisation dans l'espace et nous en
avons jusque là allègrement profité pour les calculs de distance
nécéssaires aux formules précédentes. Dans la continuité de cette
hypothèse, on peut supposer que tous les capteurs connaissent le
centre géométrique de l'environnement dans lequel ils évoluent. Cette
position peut être la position de laquelle ils ont été largués, une
position pré-programmée ou un point calculée de façon façon
décentralisée par moyenne de toutes leur positions. Le point important
est que cette position est connue de tous et sert d'origine dans leur
système de coordonnées.

La gravité est la force qui va attirer tous les capteurs vers le
centre de l'environnement. \`A première vue, une telle règle semble
dangereuse car on imagine qu'elle poussera les capteurs à se déplacer
vers le centre de la zone au risque de sacrifier l'étendue de la
superficie couverte. Néanmoins, on compte sur l'effet combiné des
différentes forces, notamment la répulsion, pour résister à cet effet.

L'interêt de la gravité est d'attirer vers un même espace les capteurs
isolés et les composantes connexes chanceuses formées par l'attraction
et équilibrées par la répulsion. On la calcule de façon uniforme,
comme un vecteur unitaire dirigé vers le centre de l'environnement.

$$
\vec{g} = -\frac{\vec{p}}{|\vec{p}|}
$$

\begin{figure}[H]

  \centering

  \input{gravite.tikz}

  \caption{La gravité attire tous les capteurs vers le centre de leur
    environnement.}
  \label{gravite}

\end{figure}

\subsection*{Composition d'une force nette}

Une fois ces trois forces évaluées, on ne peut pas les appliquer
naïvement sur le capteur concerné car il s'agit d'un objet physique
soumis à des limitations quant à sa vitesse de déplacement. On associe
donc à chaque capteur une vitesse de déplacement maximale qui servira
de borne supérieure à la magnitude des trois forces combinées.

Puisque l'on dispose de trois influences différentes, chacune tenant
un rôle particulier dans la résolution du problème, l'idée la plus
intuitive est d'en déduire une influence moyenne.

$$
\vec{f} = \frac{\vec{a} + \vec{r} + \vec{g}}{3}
$$

En pratique, on observe que ce choix montre vite ses limites. En
effet, sous certaines configurations, deux forces prendront des
directions opposées opposées et les combiner de la sorte annulera tout
mouvement. Or l'inaction est rarement une solution. Dans d'autre cas
encore plus fréquents, les trois forces semblents correctement
pondérées : on observe des capteurs isolés flotter lentement vers le
centre de leur environnement et s'assembler en composantes connexes de
plus en plus grandes. Mais une fois que le maillage est complet et
qu'une situation d'équilibre semble avoir été atteinte, le centre du
réseau commence à trembler, les capteurs centraux se rapprochent
dangereusement et se superposent sur l'origine de l'univers, ignorant
totalement la règle de répulsivité. Ce problème est dû au nombre elevé
de tensions s'opérant au centre du réseau, résultant en une pression
intense qui fait s'effondrer le réseau jusqu'à ce que tous les
capteurs occupent la même position. Moyenner les forces est donc une
fausse bonne idée.

On préférera prioritiser les forces, c'est à dire leur donner un ordre
d'importance. Le mode opératoire est le suivant :

\begin{enumerate}
\item{On définit l'ordre des forces, dans notre cas répulsion puis
  attraction puis gravité.}
\item{On calcule la force de répulsion et on l'applique en bornant par
  la vitesse maximale des capteurs.}
\item{S'il reste de la marge de man\oe uvre, on recommence cette
  opération avec l'attraction}
\item{S'il reste de la marge de man\oe uvre, on recommence cette
  opération avec la gravité}
\end{enumerate}

De cette façon, les situations d'urgence telles que l'écartement
rapide de deux capteurs trop proches prennent le pas sur des
mouvements de composition, tels que celui d'un capteur isolé flottant
vers l'origine. Ce procédé est d'ailleurs utilisé pour les boïds afin
de prioritiser l'évitement des obstacles face aux forces de cohésion
du groupe.

Pour prouver la versatilité de notre système, on propose finalement
d'étendre ce modèle de guidage afin de permettre aux capteurs d'éviter
automatiquement les obstacles par l'ajout d'une nouvelle force
virtuelle. Ici, un obstacle est défini comme étant une zone non
traversable. En réalité, il peut s'agir d'un bâtiment, d'une zone dont
les relevés ne nous intéressent pas, ou d'un espace interdit au
appareils volants. Dans un soucis de simplicité (et de délais !), on
limite les obstacles à des formes circulaires afin de mieux s'accorder
à l'aspect radial des différentes forces introduites jusqu'à présent.

Une force de répulsion du même type que celle éloignant les capteurs
les uns des autres est appliquée sur chaque obstacle et est
inversement proportionnelle à la distance jusqu'à l'obstacle afin de
provoquer des expulsions rapides. Lors de la composition de la force
appliquée au capteur, on choisit d'appliquer en priorité la nouvelle
force d'évitement des obstacles plutôt que la répulsion. Un résultat
est visible sur la figure \ref{obstacles}.

\begin{figure}[H]

  \centering

  \includegraphics[width=7cm]{obstacles.png}

  \caption{}
  \label{obstacles}

\end{figure}

\section*{Conclusion}

\end{multicols}

\begin{figure}[p]

  \centering

  \subfloat[]{\input{connexite1.tikz}}\\
  \subfloat[]{\input{connexite1.tikz}}\\
  \subfloat[]{\input{connexite1.tikz}}\\

  \caption{???}
  \label{connexite}

\end{figure}

\begin{figure}[p]

  \centering

  \subfloat[]{\includegraphics[width=7cm]{demo1.png}}
  \subfloat[]{\includegraphics[width=7cm]{demo2.png}}\\
  \subfloat[]{\includegraphics[width=7cm]{demo3.png}}
  \subfloat[]{\includegraphics[width=7cm]{demo4.png}}\\
  \subfloat[]{\includegraphics[width=7cm]{demo5.png}}

  \caption{Différentes étapes de la formation d'un réseau connexe.}
  \label{demo}

\end{figure}

\bibliographystyle{alpha}
\bibliography{references}

\end{document}
